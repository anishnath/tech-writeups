<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="go lang aes encryption decryption, go lang tutorial, go lang cryptography, go aes file encryption, go AES-GCM , go AES-CBC, go AES-CFB, go AES-CTR  ">
    <meta name="keywords" content="go lang crypto/aes, go lang security, go lang cryptography, crypto/cipher,  ">
    <meta name="author" content="Anish nath">
    <meta name="robots" content="index,follow" />
	<meta name="googlebot" content="index,follow" />
	<meta name="resource-type" content="document" />
	<meta name="classification" content="tools" />
	<meta name="language" content="en" />

    <title>go lang AES encryption decryption</title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/blog-post.css" rel="stylesheet">
    
    <link rel="stylesheet"  href="css/highlight/default.min.css">
	<script src="css/highlight/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	
	
		<!-- JSON-LD markup generated by Google Structured Data Markup Helper. -->
<!-- JSON-LD markup generated by Google Structured Data Markup Helper. -->
<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Article",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://8gwifi.org/docs/go-aes.jsp"
  },
  "name" : "go lang AES encryption decryption",
  "author" : {
    "@type" : "Person",
    "name" : "Anish"
  },
  "headline": "go lang AES encryption decryption ",
  "image":"https://8gwifi.org/docs/img/go.png",
  "datePublished" : "2019-04-03",
  "dateModified": "2019-04-03",
  "articleSection" : "go lang AES encryption decryption",
  "articleBody" : [ "Go lang AES encryption/Decryption", "AES-GCM Encryption/Decryption" , "AES-CBC Encryption/Decryption", "AES-CFB Encryption/Decryption" , "AES-CTR Encryption/Decryption" , "AES-OFB Encryption/Decryption" , "NewCipher", "crypto/cipher" , "crypto/aes"],
  "publisher" : {
    "@type" : "Organization",
    "name" : "8gwifi.org Tech Blog",
    "logo" :  {
      "@type": "ImageObject",
      "url": "https://8gwifi.org/docs/img/logo.jpg"
    }
  }
}
</script>


  </head>

  <body>

    <!-- Navigation -->
 	<%@ include file="navigation.jsp"%>

    <!-- Page Content -->
    <div class="container">

      <div class="row">

        <!-- Post Content Column -->
        <div class="col-lg-8">

          <!-- Title -->
          <h1 class="mt-4">Go lang AES encryption/Decryption</h1>

          <!-- Author -->
          <p class="lead">
            by
            <a href="https://www.linkedin.com/in/anishnath">Anish</a>
            <p>Posted on Wednesday April 3 , 2019</p>
          </p>
          
          
          
          <%@ include file="footer_adsense.jsp"%>
           <%@ include file="analytics.jsp"%>
           
           <p><mark>This sample chapter </mark> extracted from the book, <a href="https://leanpub.com/cryptog">Go Lang Cryptography for Developers </a>. The Book theme isCryptography is for EveryOne. Learn from Crypto Principle to Applied Cryptography With Practical Example<mark> Grab a Copy</mark> </p>
		   <p><iframe class="embed-responsive-item" width='160' height='400' src='https://leanpub.com/cryptog/embed' frameborder='0' allowtransparency='true'></iframe></p>
           
          <hr>
<p><strong>Advanced Encryption Standard (AES)</strong> a symmetric block cipher that can process data blocks of 128 bits, using cipher keys with lengths of <strong>128</strong>, <strong>192</strong>, and <strong>256</strong> bits. AES ( Formerly Rijndael) was designed to handle additional block sizes and key lengths, however they are not adopted in this standard.</p>
<p><strong>Key-Block-Round Combinations.</strong></p>
<p>The only Key-Block-Round combinations that conform to this standard are given in the below table.</p>
<table class="table table-striped table-bordered">
<thead>
<tr>
<th>Algo</th>
<th>key length</th>
<th>Block Size</th>
<th>Number of Rounds</th>
</tr>
</thead>
<tbody>
<tr>
<td>AES-128</td>
<td>4</td>
<td>4</td>
<td>10</td>
</tr>
<tr>
<td>AES-192</td>
<td>6</td>
<td>4</td>
<td>12</td>
</tr>
<tr>
<td>AES-256</td>
<td>8</td>
<td>4</td>
<td>14</td>
</tr>
</tbody>
</table>
<p>Go lang <strong>standard</strong> library <a href="https://godoc.org/crypto/aes">aes</a>  implements AES encryption (formerly Rijndael), as defined in U.S. Federal Information Processing Standards Publication 197</p>
<p><code>func NewCipher</code> creates and returns a new cipher.Block. The key argument should be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256</p>

<pre><code class="html"><span class="hljs-keyword">func</span> NewCipher(key []<span class="hljs-typename">byte</span>) (cipher.Block, error)
</code></pre>
<p>The following example will show how to perform AES encryption and decryption of the given plain text message</p>
<ul>
<li>The key argument should be the AES key,  either <strong>16</strong>, <strong>24</strong>, or <strong>32</strong> bytes to select <strong>AES-128</strong>, <strong>AES-192</strong>, or <strong>AES-256</strong>.</li>
</ul>

<pre><code class="html"><span class="hljs-keyword">package</span> main  
  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto/aes"</span>  
   <span class="hljs-string">"encoding/hex"</span>
   <span class="hljs-string">"fmt"</span>
  )  
  
<span class="hljs-keyword">func</span> main() {  
  
   key := <span class="hljs-string">"myverystrongpasswordo32bitlength"</span>  
   plainText := <span class="hljs-string">"Hello 8gwifi.org"</span>  
   ct := Encrypt([]<span class="hljs-typename">byte</span>(key),plainText)  
   fmt.Printf(<span class="hljs-string">"Original Text:  %s\n"</span>,plainText)  
   fmt.Printf(<span class="hljs-string">"AES Encrypted Text:  %s\n"</span>, ct)  
   Decrypt([]<span class="hljs-typename">byte</span>(key),ct)  
}  
  
<span class="hljs-keyword">func</span> Encrypt(key []<span class="hljs-typename">byte</span>, plaintext <span class="hljs-typename">string</span>) <span class="hljs-typename">string</span> {  
   c, err := aes.NewCipher(key)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Errorf(<span class="hljs-string">"NewCipher(%d bytes) = %s"</span>, <span class="hljs-built_in">len</span>(key), err)  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   out := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, <span class="hljs-built_in">len</span>(plaintext))  
   c.Encrypt(out, []<span class="hljs-typename">byte</span>(plaintext))  
  
   <span class="hljs-keyword">return</span> hex.EncodeToString(out)  
}  

<span class="hljs-keyword">func</span> Decrypt(key []<span class="hljs-typename">byte</span>, ct <span class="hljs-typename">string</span>) {    
   ciphertext, _ := hex.DecodeString(ct)  
   c, err := aes.NewCipher(key)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Errorf(<span class="hljs-string">"NewCipher(%d bytes) = %s"</span>, <span class="hljs-built_in">len</span>(key), err)  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   plain := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, <span class="hljs-built_in">len</span>(ciphertext))  
   c.Decrypt(plain, ciphertext)  
   s := <span class="hljs-typename">string</span>(plain[:])  
   fmt.Printf(<span class="hljs-string">"AES Decrypyed Text:  %s\n"</span>, s)  
}
</code></pre>
<p><strong>The Output</strong></p>

<pre><code class="html">$go run aesencdec.go
Original Text:  Hello 8gwifi.org
AES Encrypted Text:  3ed419795150ede4820f19d104d1654a
AES Decrypyed Text:  Hello 8gwifi.org
</code></pre>

<%@ include file="footer_adsense.jsp"%>
<h3><a id="AES_File_EncryptionDecryption_84"></a>AES File Encryption/Decryption</h3>
<p>This example will show how to encrypt and decrypt a given file using AES key.</p>
<ul>
<li>The IV value is fixed in this example, it can be randomized, then the user need to write/read the same IV value in the file for encryption and decryption.</li>
<li>This example uses OFB block Cipher mode, it can be tuned with the programming need.</li>
</ul>

<pre><code class="html"><span class="hljs-keyword">package</span> main  
  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto/aes"</span>  
   <span class="hljs-string">"crypto/cipher"</span>
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"io"</span>
    <span class="hljs-string">"os"</span>
    )  
  
<span class="hljs-keyword">func</span> main() {  
   <span class="hljs-comment">// Store/Load this Key secretrly  </span>
   <span class="hljs-comment">// This Shounot be hardcoded in the code.  </span>
   key := <span class="hljs-string">"myverystrongpasswordo32bitlength"</span>  
   fmt.Println(<span class="hljs-string">"====File Encryption/ Decryption===="</span>)  
   infileName := <span class="hljs-string">"/tmp/hello.txt"</span>  
   encfileName := <span class="hljs-string">"/tmp/hello.txt.enc"</span>  
   decfileName := <span class="hljs-string">"/tmp/hello.txt.dec"</span>  
   FileEncryption(key,infileName,encfileName)  
   FileDecryption(key,encfileName,decfileName)  
}  
  
<span class="hljs-keyword">func</span> FileEncryption(key <span class="hljs-typename">string</span>, infileName <span class="hljs-typename">string</span>, encfileName <span class="hljs-typename">string</span>)  {  
   inFile, err := os.Open(infileName)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   <span class="hljs-keyword">defer</span> inFile.Close()  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   <span class="hljs-comment">// If the key is unique for each ciphertext, then it's ok to use a zero  </span>
   <span class="hljs-comment">// IV.  var iv [aes.BlockSize]byte  </span>
   stream := cipher.NewOFB(block, iv[:])  
   outFile, err := os.OpenFile(encfileName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, <span class="hljs-number">0600</span>)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   <span class="hljs-keyword">defer</span> outFile.Close()  
  
   writer := &amp;cipher.StreamWriter{S: stream, W: outFile}  
   <span class="hljs-comment">// Copy the input file to the output file, encrypting as we go.  </span>
  <span class="hljs-keyword">if</span> _, err := io.Copy(writer, inFile); err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
}  
  
  
<span class="hljs-keyword">func</span> FileDecryption(key <span class="hljs-typename">string</span>, encfileName <span class="hljs-typename">string</span>, decfileName <span class="hljs-typename">string</span>)  {  
   inFile, err := os.Open(encfileName)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   <span class="hljs-keyword">defer</span> inFile.Close()  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   <span class="hljs-comment">// If the key is unique for each ciphertext, then it's ok to use a zero  </span>
   <span class="hljs-comment">// IV.  var iv [aes.BlockSize]byte  </span>
   stream := cipher.NewOFB(block, iv[:])  
   outFile, err := os.OpenFile(decfileName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, <span class="hljs-number">0600</span>)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   <span class="hljs-keyword">defer</span> outFile.Close()  
   reader := &amp;cipher.StreamReader{S: stream, R: inFile}  
   <span class="hljs-comment">// Copy the input file to the output file, decrypting as we go.  </span>
  <span class="hljs-keyword">if</span> _, err := io.Copy(outFile, reader); err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
}
</code></pre>

<pre><code class="html">$go run aesfileencdec.go
====File Encryption/ Decryption====

$ cat /tmp/hello.txt
Hello 8gwifi.org
$ cat /tmp/hello.txt.enc
!/=)0??7?PIS????0A
$ cat /tmp/hello.txt.dec
Hello 8gwifi.org
</code></pre>
<p></p>
<%@ include file="footer_adsense.jsp"%>
<h3><a id="AESGCM_EncryptionDecryption_183"></a>AES-GCM Encryption/Decryption</h3>
<p><a href="http://en.wikipedia.org/wiki/Galois/Counter_Mode">GCM</a>  is a block cipher  <a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29">counter mode</a>  with authentication. A Counter mode effectively turns a block cipher into a stream cipher, and therefore many of the rules for stream ciphers still apply.</p>
<ul>
<li>GCM mode provides both privacy (encryption) and integrity.</li>
<li>GCM uses an IV (or Nonce)</li>
<li>Same(Key) + Same (IV) will always produce same PRNG stream, so for best security practices always re-generate the IV while performing encryption and use the same IV for decryption.</li>
<li>GCM is <strong>authenticated</strong> <strong>encryption</strong> (both encryption and message integrity)</li>
</ul>
<p>The following example will show how to perform encryption and decryption in GCM Mode with and without AAD data.</p>

<pre><code class="html"><span class="hljs-keyword">package</span> main  
  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto/aes"</span>  
   <span class="hljs-string">"crypto/cipher"</span> 
   <span class="hljs-string">"crypto/rand"</span> 
   <span class="hljs-string">"encoding/hex"</span> 
   <span class="hljs-string">"fmt"</span> 
   <span class="hljs-string">"io"</span>
   )  
  
<span class="hljs-keyword">func</span> main() {  
  
  <span class="hljs-comment">// Must Kept Secret No Hardcoding , This is for Demo purpose.</span>
   key := <span class="hljs-string">"myverystrongpasswordo32bitlength"</span>  
   plainText := <span class="hljs-string">"Hello 8gwifi.org"</span>  
   fmt.Printf(<span class="hljs-string">"Original Text:  %s\n"</span>,plainText)  
   fmt.Println()  
   fmt.Println(<span class="hljs-string">"====GCM Encryption/ Decryption Without AAD===="</span>)  
  
   <span class="hljs-comment">// Never use more than 2^32 random nonces with a given key because of the risk of a repeat.  </span>
  iv := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, <span class="hljs-number">12</span>)  
   <span class="hljs-keyword">if</span> _, err := io.ReadFull(rand.Reader, iv); err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err.Error())  
   }  
   ciphertext := GCM_encrypt(key,plainText,iv,<span class="hljs-constant">nil</span>)  
   fmt.Printf(<span class="hljs-string">"GCM Encrypted Text:  %s\n"</span>, ciphertext)  
   ret := GCM_decrypt(key,ciphertext,iv,<span class="hljs-constant">nil</span>)  
   fmt.Printf(<span class="hljs-string">"GCM Decrypted Text:  %s\n"</span>, ret)  
   fmt.Println()  
  
   fmt.Println(<span class="hljs-string">"====GCM Encryption/ Decryption Using AAD===="</span>)  
  
   <span class="hljs-comment">// Never Use Same IV or Nonce  </span>
   iv = <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, <span class="hljs-number">12</span>)  
   <span class="hljs-keyword">if</span> _, err := io.ReadFull(rand.Reader, iv); err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err.Error())  
   }  
   additionalData := <span class="hljs-string">"Not Secret AAD Value"</span>  
   ciphertext = GCM_encrypt(key,plainText,iv, []<span class="hljs-typename">byte</span>(additionalData))  
   fmt.Printf(<span class="hljs-string">"GCM Encrypted Text:  %s\n"</span>, ciphertext)  
   ret = GCM_decrypt(key,ciphertext,iv, []<span class="hljs-typename">byte</span>(additionalData))  
  
   fmt.Printf(<span class="hljs-string">"GCM Decrypted Text:  %s\n"</span>, ret)  
  
}  

<span class="hljs-keyword">func</span> GCM_encrypt(key <span class="hljs-typename">string</span>, plaintext <span class="hljs-typename">string</span>, iv []<span class="hljs-typename">byte</span>, additionalData []<span class="hljs-typename">byte</span>) <span class="hljs-typename">string</span> {  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err.Error())  
   }  
   aesgcm, err := cipher.NewGCM(block)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err.Error())  
   }  
   ciphertext := aesgcm.Seal(<span class="hljs-constant">nil</span>, iv, []<span class="hljs-typename">byte</span>(plaintext), additionalData)  
   <span class="hljs-keyword">return</span> hex.EncodeToString(ciphertext)  
}  
  
<span class="hljs-keyword">func</span> GCM_decrypt(key <span class="hljs-typename">string</span>,ct <span class="hljs-typename">string</span>,iv []<span class="hljs-typename">byte</span>, additionalData []<span class="hljs-typename">byte</span>) <span class="hljs-typename">string</span> {  
   ciphertext, _ := hex.DecodeString(ct)  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err.Error())  
   }  
   aesgcm, err := cipher.NewGCM(block)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err.Error())  
   }  
   plaintext, err := aesgcm.Open(<span class="hljs-constant">nil</span>, iv, ciphertext, additionalData)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err.Error())  
   }  
   s := <span class="hljs-typename">string</span>(plaintext[:])  
   <span class="hljs-keyword">return</span> s  
}
</code></pre>
<p><strong>The Output</strong></p>

<pre><code class="html">$ go run aesgcm-encdec.go
Original Text:  Hello 8gwifi.org

====GCM Encryption/ Decryption Without AAD====
GCM Encrypted Text:  00cefd9fb96388fcec4ba862164e9ff97428cfa01cdb962c041f825e06c40659
GCM Decrypted Text:  Hello 8gwifi.org

====GCM Encryption/ Decryption Using AAD====
GCM Encrypted Text:  bb0b4485d9fb0874d1e051eab6a93931d2817d855a23a4446dd0e94211a92afb
GCM Decrypted Text:  Hello 8gwifi.org

</code></pre>
<p></p>
<%@ include file="footer_adsense.jsp"%>
<h3><a id="AESCBC_EncryptionDecryption_293"></a>AES-CBC Encryption/Decryption</h3>
<p>In CBC mode, each block of plaintext is <a href="https://en.wikipedia.org/wiki/XOR" title="XOR">XORed</a> with the previous ciphertext block before being encrypted.</p>
<ul>
<li>In CBC Mode the given plaintext should be <strong>multiple</strong> of AES block size.</li>
<li>If the original plaintext lengths are not a multiple of the block size, padding would have to be added when encrypting</li>
<li>The <strong>IV</strong> value should be <strong>equal</strong> to AES block size.</li>
<li>CBC is block ciphers modes, <strong>encryption but not message integrity</strong></li>
</ul>
<p>The following example will show how to perform encryption and decryption in CBC Mode</p>

<pre><code class="html"><span class="hljs-keyword">package</span> main  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto/aes"</span>  
   <span class="hljs-string">"crypto/cipher"</span> 
   <span class="hljs-string">"crypto/rand"</span>
   <span class="hljs-string">"encoding/hex"</span> 
   <span class="hljs-string">"fmt"</span>
   <span class="hljs-string">"io"</span>
   )  
  
<span class="hljs-keyword">func</span> main() {  

  <span class="hljs-comment">// Must Kept Secret No Hardcoding , This is for Demo purpose.</span>
   key := <span class="hljs-string">"myverystrongpasswordo32bitlength"</span>  
  
  <span class="hljs-comment">// IN CBC Must be Block Size of AES (Multiple of 16)  </span>
  <span class="hljs-comment">// Other WIse Paddign needs to be perfomed  </span>
   plainText := <span class="hljs-string">"Hello 8gwifi.org"</span>   
  
   <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(plainText)%aes.BlockSize != <span class="hljs-number">0</span> {  
      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"plaintext is not a multiple of the block size"</span>)  
   }  
  
   fmt.Printf(<span class="hljs-string">"Original Text:  %s\n"</span>,plainText)  
   fmt.Println(<span class="hljs-string">"====CBC Encryption/ Decryption===="</span>)  
   <span class="hljs-comment">// IV Length Must be equal to Block Size.  </span>
   iv := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, aes.BlockSize)  
   <span class="hljs-keyword">if</span> _, err := io.ReadFull(rand.Reader, iv); err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err.Error())  
   }  
   ciphertext := CBCEncrypter(key,plainText,iv,<span class="hljs-constant">nil</span>)  
   fmt.Printf(<span class="hljs-string">"CBC Encrypted Text:  %s\n"</span>, ciphertext)  
   ret := CBCDecrypter(key,ciphertext,iv,<span class="hljs-constant">nil</span>)  
   fmt.Printf(<span class="hljs-string">"CBC Decrypted Text:  %s\n"</span>, ret)  
}  

<span class="hljs-keyword">func</span> CBCEncrypter(key <span class="hljs-typename">string</span>, plaintext <span class="hljs-typename">string</span>, iv []<span class="hljs-typename">byte</span>, additionalData []<span class="hljs-typename">byte</span>) <span class="hljs-typename">string</span> {  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }   
   <span class="hljs-comment">// include it at the beginning of the ciphertext.  </span>
   ciphertext := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, aes.BlockSize+<span class="hljs-built_in">len</span>(plaintext))  
   mode := cipher.NewCBCEncrypter(block, iv)  
   mode.CryptBlocks(ciphertext[aes.BlockSize:], []<span class="hljs-typename">byte</span>(plaintext))  
   <span class="hljs-keyword">return</span> hex.EncodeToString(ciphertext)  
}  

<span class="hljs-keyword">func</span> CBCDecrypter(key <span class="hljs-typename">string</span>,ct <span class="hljs-typename">string</span>,iv []<span class="hljs-typename">byte</span>, additionalData []<span class="hljs-typename">byte</span>) <span class="hljs-typename">string</span> {  
   ciphertext, _ := hex.DecodeString(ct)  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   ciphertext = ciphertext[aes.BlockSize:]  
   <span class="hljs-comment">// CBC mode always works in whole blocks.  </span>
  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ciphertext)%aes.BlockSize != <span class="hljs-number">0</span> {  
      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"ciphertext is not a multiple of the block size"</span>)  
   }  
   mode := cipher.NewCBCDecrypter(block, iv)  
   <span class="hljs-comment">// CryptBlocks can work in-place if the two arguments are the same.  </span>
   mode.CryptBlocks(ciphertext, ciphertext)  
   s := <span class="hljs-typename">string</span>(ciphertext[:])  
  
   <span class="hljs-keyword">return</span> s  
}
</code></pre>
<p><strong>The Output</strong></p>
<pre><code class="html">$ go run aescbc-encdec.go
Original Text:  Hello 8gwifi.org
====CBC Encryption/ Decryption====
CBC Encrypted Text:  000000000000000000000000000000000c22a1fa436a571e6b16dd258b56dcd4
CBC Decrypted Text:  Hello 8gwifi.org
</code></pre>
<p></p>
<h3><a id="AESCFB_EncryptionDecryption_386"></a>AES-CFB Encryption/Decryption</h3>
<p>The <em>Cipher Feedback</em> (CFB) mode, a close relative of CBC, makes a block cipher into a self-synchronizing <a href="https://en.wikipedia.org/wiki/Stream_cipher" title="Stream cipher">stream cipher</a>. Operation is very similar; in particular, CFB decryption is almost identical to CBC encryption performed in reverse:</p>
<ul>
<li><strong>CFB</strong>'s pseudo random stream depends on the plaintext</li>
<li>A different <strong>nonce</strong> or random <strong>IV</strong> is needed for every message.</li>
<li>CFB is block ciphers modes, <strong>encryption but not message integrity</strong></li>
</ul>

<pre><code class="html"><span class="hljs-keyword">package</span> main  
  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto/aes"</span>  
   <span class="hljs-string">"crypto/cipher"</span> 
   <span class="hljs-string">"crypto/rand"</span> 
   <span class="hljs-string">"encoding/hex"</span> 
   <span class="hljs-string">"fmt"</span> 
   <span class="hljs-string">"io"</span>
   )  
  
<span class="hljs-keyword">func</span> main() {  
  
   <span class="hljs-comment">// 32 bit length key, for demo pupose hardcoded  </span>
  <span class="hljs-comment">// Secure this key in production No hardcoding  key := "myverystrongpasswordo32bitlength"  </span>
   plainText := <span class="hljs-string">"Hello 8gwifi.org "</span>  
   fmt.Printf(<span class="hljs-string">"Original Text:  %s\n"</span>,plainText)  
   fmt.Println(<span class="hljs-string">"====CFB Encryption/ Decryption===="</span>)  
  
   <span class="hljs-comment">// IV Length Must be equal to Block Size.  </span>
   iv := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, aes.BlockSize)  
   <span class="hljs-keyword">if</span> _, err := io.ReadFull(rand.Reader, iv); err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err.Error())  
   }  
   ciphertext := CFBEncrypter(key,plainText,iv,<span class="hljs-constant">nil</span>)  
   fmt.Printf(<span class="hljs-string">"CFB Encrypted Text:  %s\n"</span>, ciphertext)  
   ret := CFBDecrypter(key,ciphertext,iv,<span class="hljs-constant">nil</span>)  
   fmt.Printf(<span class="hljs-string">"CFB Decrypted Text:  %s\n"</span>, ret)  
}  

<span class="hljs-keyword">func</span> CFBEncrypter(key <span class="hljs-typename">string</span>, plaintext <span class="hljs-typename">string</span>, iv []<span class="hljs-typename">byte</span>, additionalData []<span class="hljs-typename">byte</span>) <span class="hljs-typename">string</span> {  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   ciphertext := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, aes.BlockSize+<span class="hljs-built_in">len</span>(plaintext))  
   stream := cipher.NewCFBEncrypter(block, iv)  
   stream.XORKeyStream(ciphertext[aes.BlockSize:], []<span class="hljs-typename">byte</span>(plaintext))  
   <span class="hljs-keyword">return</span> hex.EncodeToString(ciphertext)  
}  

<span class="hljs-keyword">func</span> CFBDecrypter(key <span class="hljs-typename">string</span>,ct <span class="hljs-typename">string</span>,iv []<span class="hljs-typename">byte</span>, additionalData []<span class="hljs-typename">byte</span>) <span class="hljs-typename">string</span> {  
  
   ciphertext, _ := hex.DecodeString(ct)  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   ciphertext = ciphertext[aes.BlockSize:]  
  
   stream := cipher.NewCFBDecrypter(block, iv)  
   <span class="hljs-comment">// XORKeyStream can work in-place if the two arguments are the same.  </span>
  stream.XORKeyStream(ciphertext, ciphertext)  
   s := <span class="hljs-typename">string</span>(ciphertext[:])  
  
   <span class="hljs-keyword">return</span> s  
}
</code></pre>
<p><strong>The Output</strong></p>

<pre><code class="html">$ go run aescfb-encdec.go
Original Text:  Hello 8gwifi.org 
====CFB Encryption/ Decryption====
CFB Encrypted Text:  00000000000000000000000000000000966561e216b0757f9e0d6093511fba9b6b
CFB Decrypted Text:  Hello 8gwifi.org 
</code></pre>
<p></p>
<%@ include file="footer_adsense.jsp"%>
<h3><a id="AESCTR_EncryptionDecryption_468"></a>AES-CTR Encryption/Decryption</h3>
<p>CTR mode has similar characteristics to OFB, but also allows a random access property during decryption. CTR mode is well suited to operate on a multi-processor machine where blocks can be encrypted in parallel. Furthermore, it does not suffer from the short-cycle problem that can affect OFB.</p>
<ul>
<li>In CTR Mode the given plaintext should be <strong>multiple</strong> of AES block size.</li>
<li>If the original plaintext lengths are not a multiple of the block size, padding would have to be added when encrypting</li>
<li>The <strong>IV</strong> value should be <strong>equal</strong> to AES block size.</li>
<li>CTR is block ciphers modes, <strong>encryption but not message integrity</strong></li>
<li>Because of the symmetry of the <strong>XOR</strong> operation, encryption and decryption are exactly the same</li>
</ul>
<p>The following example will show how to perform encryption and decryption in <strong>CTR</strong> Mode</p>

<pre><code class="html"><span class="hljs-keyword">package</span> main  
  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto/aes"</span>  
   <span class="hljs-string">"crypto/cipher"</span> 
   <span class="hljs-string">"crypto/rand"</span> 
   <span class="hljs-string">"encoding/hex"</span> 
   <span class="hljs-string">"fmt"</span> 
   <span class="hljs-string">"io"</span>
   )  
  
<span class="hljs-keyword">func</span> main() {  
  
   <span class="hljs-comment">// 32 bit length key, Most be secured in production ENV  </span>
   <span class="hljs-comment">// No Hardcoding of the key  </span>
   key := <span class="hljs-string">"myverystrongpasswordo32bitlength"</span>  
   
  <span class="hljs-comment">// IN CTR Mode the plaintext shoun't be Must be Block Size of AES (Multiple of 16)  </span>
   <span class="hljs-comment">// Other WIse Paddign needs to be perfomed  </span>
   plainText := <span class="hljs-string">"Hello 8gwifi.org"</span>   
   <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(plainText)%aes.BlockSize != <span class="hljs-number">0</span> {  
      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"plaintext is not a multiple of the block size"</span>)  
   }  
   fmt.Printf(<span class="hljs-string">"Original Text:  %s\n"</span>,plainText)  
   fmt.Println(<span class="hljs-string">"====CTR Encryption/ Decryption===="</span>)  
   <span class="hljs-comment">// IV Length Must be equal to Block Size.  </span>
   iv := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, aes.BlockSize)  
   <span class="hljs-keyword">if</span> _, err := io.ReadFull(rand.Reader, iv); err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err.Error())  
   }  
   ciphertext := CTREncrypter(key,plainText,iv)  
   fmt.Printf(<span class="hljs-string">"CTR Encrypted Text:  %s\n"</span>, ciphertext)  
   ret := CTRDecrypter(key,ciphertext,iv)  
   fmt.Printf(<span class="hljs-string">"CTR Decrypted Text:  %s\n"</span>, ret)  
}  

<span class="hljs-keyword">func</span> CTREncrypter(key <span class="hljs-typename">string</span>, plaintext <span class="hljs-typename">string</span>, iv []<span class="hljs-typename">byte</span>) <span class="hljs-typename">string</span> {  
  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   ciphertext := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, aes.BlockSize+<span class="hljs-built_in">len</span>(plaintext))  
   stream := cipher.NewCTR(block, iv)  
   stream.XORKeyStream(ciphertext[aes.BlockSize:], []<span class="hljs-typename">byte</span>(plaintext))  
   <span class="hljs-keyword">return</span> hex.EncodeToString(ciphertext)  
}  

<span class="hljs-keyword">func</span> CTRDecrypter(key <span class="hljs-typename">string</span>,ct <span class="hljs-typename">string</span>,iv []<span class="hljs-typename">byte</span>) <span class="hljs-typename">string</span> {  
   ciphertext, _ := hex.DecodeString(ct)  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   ciphertext = ciphertext[aes.BlockSize:]  
   <span class="hljs-comment">// CBC mode always works in whole blocks.  </span>
  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ciphertext)%aes.BlockSize != <span class="hljs-number">0</span> {  
      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"ciphertext is not a multiple of the block size"</span>)  
   }  
   mode := cipher.NewCTR(block, iv)  
   mode.XORKeyStream(ciphertext, ciphertext)  
   s := <span class="hljs-typename">string</span>(ciphertext[:])  
  
   <span class="hljs-keyword">return</span> s  
}
</code></pre>
<p><strong>The output</strong></p>

<pre><code class="html">$ go run aesctr-encdec.go
Original Text:  Hello 8gwifi.org
====CTR Encryption/ Decryption====
CTR Encrypted Text:  00000000000000000000000000000000df59bc82ae31c833a58fc8641a7ef119
CTR Decrypted Text:  Hello 8gwifi.org
</code></pre>
<p></p>
<h3><a id="AESOFB_EncryptionDecryption_560"></a>AES-OFB Encryption/ Decryption</h3>
<p>The <em>Output Feedback</em> (OFB) mode makes a block cipher into a synchronous <a href="https://en.wikipedia.org/wiki/Stream_cipher" title="Stream cipher">stream cipher</a>. It generates <a href="https://en.wikipedia.org/wiki/Keystream" title="Keystream">keystream</a> blocks, which are then <a href="https://en.wikipedia.org/wiki/XOR" title="XOR">XORed</a> with the plaintext blocks to get the ciphertext. Just as with other stream ciphers, flipping a bit in the ciphertext produces a flipped bit in the plaintext at the same location</p>
<ul>
<li>In OFB Mode the given plaintext should be <strong>multiple</strong> of AES block size.</li>
<li>If the original plaintext lengths are not a multiple of the block size, padding would have to be added when encrypting</li>
<li>The <strong>IV</strong> value should be <strong>equal</strong> to AES block size.</li>
<li>OFB is block ciphers modes, <strong>encryption but not message integrity</strong></li>
<li>Because of the symmetry of the <strong>XOR</strong> operation, encryption and decryption are exactly the same</li>
</ul>
<p>The following example will show how to perform encryption and decryption in <strong>OFB</strong> Mode</p>

<pre><code class="html"><span class="hljs-keyword">package</span> main  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto/aes"</span>  
   <span class="hljs-string">"crypto/cipher"</span> 
   <span class="hljs-string">"crypto/rand"</span> 
   <span class="hljs-string">"encoding/hex"</span> 
   <span class="hljs-string">"fmt"</span> 
   <span class="hljs-string">"io"</span>
   )  
  
<span class="hljs-keyword">func</span> main() {  
   <span class="hljs-comment">// 32 bit length key, Most be secured in production ENV  </span>
   <span class="hljs-comment">// No Hardcoding of the key  </span>
   key := <span class="hljs-string">"myverystrongpasswordo32bitlength"</span>  
   
   <span class="hljs-comment">// IN OFB Mode the plaintext shoun't be Must be Block Size of AES (Multiple of 16)  </span>
   <span class="hljs-comment">// Other WIse Paddign needs to be perfomed  </span>
   plainText := <span class="hljs-string">"Hello 8gwifi.org"</span>   
   <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(plainText)%aes.BlockSize != <span class="hljs-number">0</span> {  
      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"plaintext is not a multiple of the block size"</span>)  
   }  
   fmt.Printf(<span class="hljs-string">"Original Text:  %s\n"</span>,plainText)  
   fmt.Println(<span class="hljs-string">"====OFB Encryption/ Decryption===="</span>)  
  
   <span class="hljs-comment">// IV Length Must be equal to Block Size.  </span>
   iv := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, aes.BlockSize)  
   <span class="hljs-keyword">if</span> _, err := io.ReadFull(rand.Reader, iv); err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err.Error())  
   }  
   ciphertext := OFBEncrypter(key,plainText,iv)  
   fmt.Printf(<span class="hljs-string">"OFB Encrypted Text:  %s\n"</span>, ciphertext)  
   ret := OFBDecrypter(key,ciphertext,iv)  
   fmt.Printf(<span class="hljs-string">"OFB Decrypted Text:  %s\n"</span>, ret)  
}  
  
  
<span class="hljs-keyword">func</span> OFBEncrypter(key <span class="hljs-typename">string</span>, plaintext <span class="hljs-typename">string</span>, iv []<span class="hljs-typename">byte</span>) <span class="hljs-typename">string</span> {  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   ciphertext := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, aes.BlockSize+<span class="hljs-built_in">len</span>(plaintext))  
   stream := cipher.NewOFB(block, iv)  
   stream.XORKeyStream(ciphertext[aes.BlockSize:], []<span class="hljs-typename">byte</span>(plaintext))  
   <span class="hljs-keyword">return</span> hex.EncodeToString(ciphertext)  
}  
  
  
  
<span class="hljs-keyword">func</span> OFBDecrypter(key <span class="hljs-typename">string</span>,ct <span class="hljs-typename">string</span>,iv []<span class="hljs-typename">byte</span>) <span class="hljs-typename">string</span> {  
   ciphertext, _ := hex.DecodeString(ct)  
   block, err := aes.NewCipher([]<span class="hljs-typename">byte</span>(key))  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      <span class="hljs-built_in">panic</span>(err)  
   }  
   ciphertext = ciphertext[aes.BlockSize:]  
   <span class="hljs-comment">// CBC mode always works in whole blocks.  </span>
   <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ciphertext)%aes.BlockSize != <span class="hljs-number">0</span> {  
      <span class="hljs-built_in">panic</span>(<span class="hljs-string">"ciphertext is not a multiple of the block size"</span>)  
   }  
   mode := cipher.NewOFB(block, iv)  
   mode.XORKeyStream(ciphertext, ciphertext)  
   s := <span class="hljs-typename">string</span>(ciphertext[:])  
   <span class="hljs-keyword">return</span> s  
}
</code></pre>
<p><strong>The Output</strong></p>

<pre><code class="html">$ go run aesofb-encdec.go
Original Text:  Hello 8gwifi.org
====OFB Encryption/ Decryption====
OFB Encrypted Text:  00000000000000000000000000000000eb53ce7fe03a5cd2ea4551acbe5ea2b7
OFB Decrypted Text:  Hello 8gwifi.org
</code></pre>

<%@ include file="thanks.jsp"%>

<hr>

<%@ include file="addcomments.jsp"%>
      <!-- Comments Form -->
    

          <!-- Single Comment -->
 

          <!-- Comment with nested comments -->
        
          

        </div>

		
        
        <!-- Sidebar Widgets Column -->
        <div class="col-md-4">

          <!-- Ad Widget -->
         <%@ include file="footer_adsense.jsp"%> 
         
         
         <%@ include file="related-go.jsp"%>
         
         <%@ include file="related-cryptography.jsp"%>
         
         <%@ include file="related-window-crypto.jsp"%>

		 
          <!-- Article Widget -->
         <%@ include file="related-ansible.jsp"%>
         
         <%@ include file="related-kube.jsp"%>
         
         
         <%@ include file="related-openstack.jsp"%>
         <%@ include file="related-linux.jsp"%>
         
         
         <!-- Topic Widget -->
         <%@ include file="side.jsp"%>
         
           <!-- Add Comments Support -->
         
         
         

        </div>


      </div>
      
      <!-- /.row -->

    </div>
    
    
    
    
    <!-- /.container -->

    <!-- Footer -->
    <footer class="py-5 bg-dark">
      <div class="container">
        <p class="m-0 text-center text-white">Copyright &copy; 8gwifi.org 2018</p>
      </div>
      <!-- /.container -->
    </footer>
    
    Here

    <!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>


  </body>

</html>