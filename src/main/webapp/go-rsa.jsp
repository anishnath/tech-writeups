<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="go lang rsa, go lang generate rsa keys, go lang rsa encryption decryption, go lang GenerateMultiPrimeKey, go lang RSA OAEP, go lang RSA_PKCS1-V1_5 Sign Verify, go lang RSA_PSS Sign/Verify, go lang Export RSA Key to PEM Format, export, import PEM Key to RSA Format ">
    <meta name="keywords" content="go lang rsa, go lang generate rsa keys, go lang rsa encryption decryption, go lang GenerateMultiPrimeKey, go lang RSA OAEP, go lang RSA_PKCS1-V1_5 Sign Verify, go lang RSA_PSS Sign/Verify, go lang Export RSA Key to PEM Format, export, import PEM Key to RSA Format, go lang tutorial go lang security tutorial ">
    <meta name="author" content="Anish nath">
    <meta name="robots" content="index,follow" />
	<meta name="googlebot" content="index,follow" />
	<meta name="resource-type" content="document" />
	<meta name="classification" content="tools" />
	<meta name="language" content="en" />

    <title>go lang rsa, go lang generate rsa keys, go lang rsa encryption decryption, go lang GenerateMultiPrimeKey, go lang RSA OAEP, go lang RSA_PKCS1-V1_5 Sign Verify, go lang RSA_PSS Sign/Verify, go lang Export RSA Key to PEM Format, export, import PEM Key to RSA Format </title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/blog-post.css" rel="stylesheet">
    
    <link rel="stylesheet"  href="css/highlight/default.min.css">
	<script src="css/highlight/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	
	
		<!-- JSON-LD markup generated by Google Structured Data Markup Helper. -->
<!-- JSON-LD markup generated by Google Structured Data Markup Helper. -->
<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Article",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://8gwifi.org/docs/go-rsa.jsp"
  },
  "name" : ">go lang rsa, go lang generate rsa keys, go lang rsa encryption decryption, go lang GenerateMultiPrimeKey, go lang RSA OAEP, go lang RSA_PKCS1-V1_5 Sign Verify, go lang RSA_PSS Sign/Verify",
  "author" : {
    "@type" : "Person",
    "name" : "Anish"
  },
  "headline": ">go lang rsa, go lang generate rsa keys, go lang rsa encryption decryption, go lang GenerateMultiPrimeKey, go lang RSA OAEP, go lang RSA_PKCS1-V1_5 Sign Verify, go lang RSA_PSS Sign/Verify",
  "image":"https://8gwifi.org/docs/img/golang_png.png",
  "datePublished" : "2018-11-13",
  "dateModified": "2018-11-13",
  "articleSection" : "Go Lang RSA Cryptography ",
  "articleBody" : [ "RSA", "RSAES-OAEP and RSAES-PKCS1-v1_5 are two Encryption Schemes." , "RSAES-OAEP is recommended for new applications", "RSA public key and RSA private key are two key types" , "golang Generating RSA keys" , "GenerateMultiPrimeKey" , "RSA OAEP Encryption/Decryption", "go lang RSA_PKCS1-V1_5 Sign/Verify" , "RSA_PSS Sign/Verify
", "go lang Export RSA Key to PEM Format" , "go lang Import PEM Key to RSA Format"],
  "publisher" : {
    "@type" : "Organization",
    "name" : "8gwifi.org Tech Blog",
    "logo" :  {
      "@type": "ImageObject",
      "url": "https://8gwifi.org/docs/img/logo.jpg"
    }
  }
}
</script>


  </head>

  <body>

    <!-- Navigation -->
 	<%@ include file="navigation.jsp"%>

    <!-- Page Content -->
    <div class="container">

      <div class="row">

        <!-- Post Content Column -->
        <div class="col-lg-8">

          <!-- Title -->
          <h1 class="mt-4">Go Lang RSA Cryptography</h1>

          <!-- Author -->
          <p class="lead">
            by
            <a href="https://www.linkedin.com/in/anishnath">Anish</a>
            <p>Posted on Tuesday November 13 , 2018</p>
          </p>
          
          
          
          <%@ include file="footer_adsense.jsp"%>
           <%@ include file="analytics.jsp"%>
           
          <hr>
          
          <h1><a id="RSA_0"></a>RSA</h1>
		  <p><strong>RSA</strong> (<strong>Rivest Shamir Adleman</strong>) is one of the first <a href="https://en.wikipedia.org/wiki/Public-key_cryptography" title="Public-key cryptography">public-key cryptosystems</a> and is widely used for secure data transmission. In such a <a href="https://en.wikipedia.org/wiki/Cryptosystem" title="Cryptosystem">cryptosystem</a>, the <a href="https://en.wikipedia.org/wiki/Encryption_key" title="Encryption key">encryption key</a> is public and it is different from the <a href="https://en.wikipedia.org/wiki/Decryption_key" title="Decryption key">decryption key</a> which is kept secret (private).</p>
<ol>
<li>The original specification for encryption and signatures with RSA is <strong>PKCS#1</strong>.</li>
<li>In version two called by <strong>OAEP</strong> and <strong>PSS</strong>.</li>
<li><strong>RSAES-OAEP</strong> and <strong>RSAES-PKCS1-v1_5</strong> are two <strong><em>Encryption</em></strong> Schemes.</li>
<li><strong>RSAES-OAEP</strong> is recommended for new applications</li>
<li><strong>RSAES-PKCS1-v1_5</strong> is included only for compatibility with existing applications, and is not recommended for new applications</li>
<li><strong>RSASSA-PSS</strong> and <strong>RSASSA-PKCS1-v1_5</strong> are two <strong><em>Signature</em></strong> Schemes</li>
<li><strong>RSASSA-PSS</strong> is recommended for eventual adoption in new applications</li>
</ol>
<p><strong>Key Type</strong></p>
<p>RSA public key and RSA private key are two key types. Together, an RSA public key and an RSA private key form an RSA key pair.</p>
<p>An RSA  <em>Public Key</em>  consists of two numbers:</p>
<ul>
<li>the modulus (e.g. a 2,048 bit number)</li>
<li>the exponent (usually 65,537)</li>
</ul>
<p>An RSA <em>Private Key</em> may have either of two representations.</p>
<ol>
<li>The <strong>First</strong> representation consists of</li>
</ol>
<ul>
<li><strong>n</strong> the RSA modulus, a positive integer</li>
<li><strong>d</strong> the RSA private exponent, a positive integer</li>
</ul>
<ol start="2">
<li>The <strong>Second</strong> representation consists of a quintuple (<strong>p, q, dP, dQ, qInv</strong>) and a (possibly empty) sequence of triplets (<strong>r_i, d_i, t_i)</strong>
<ul>
<li><strong>p</strong> the first factor, a positive integer</li>
<li><strong>q</strong> the second factor, a positive integer</li>
<li><strong>dP</strong> the first factor’s CRT exponent, a positive integer</li>
<li><strong>dQ</strong> the second factor’s CRT exponent, a positive integer</li>
<li><strong>qInv</strong> the (first) CRT coefficient, a positive integer</li>
<li><strong>r_i</strong> the i-th factor, a positive integer</li>
<li><strong>d_i</strong> the i-th factor’s CRT exponent, a positive integer</li>
<li><strong>t_i</strong> the i-th factor’s CRT coefficient, a positive integer</li>
</ul>
</li>
</ol>
<p><strong>Key Size</strong><br>
RSA keys are typically 1024 to 4096 bits long</p>
<p>Go Package <a href="https://godoc.org/crypto/rsa">rsa</a>  implements RSA encryption as specified in PKCS#1.</p>
<hr>
<h2><a id="Generating_RSA_keys_43"></a>Generating RSA keys</h2>
<p><code>GenerateKey</code> generates an RSA keypair of the given bit size using the random source random.</p>
<p>Go Lang function <code>GenerateKey</code> .</p>
<pre><code>func GenerateKey(random io.Reader, bits int) (*PrivateKey, error)
</code></pre>
<p>for example the following go snippet will generate RSA  key pair of size 2048 and 1024.</p>
<pre><code class="language-go"><span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto/rand"</span>  
   <span class="hljs-string">"crypto/rsa"</span> 
   <span class="hljs-string">"fmt"</span> 
   <span class="hljs-string">"os"</span>
   )  
  
<span class="hljs-keyword">func</span> main() {  
   <span class="hljs-comment">// Generate Alice RSA keys Of 2048 Buts  </span>
  alicePrivateKey, err := rsa.GenerateKey(rand.Reader, <span class="hljs-number">2048</span>)  
  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(err.Error)  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-comment">// Extract Public Key from RSA Private Key  </span>
   alicePublicKey := alicePrivateKey.PublicKey  
  
   fmt.Println(<span class="hljs-string">"Alice Private Key (2048) :  "</span>, *alicePrivateKey)  
   fmt.Println(<span class="hljs-string">"Alice Public key (2048) "</span>, alicePublicKey)  
  
   alicePrivateKey, err = rsa.GenerateKey(rand.Reader, <span class="hljs-number">1024</span>)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(err.Error)  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-comment">// Extract Public Key from RSA Private Key  </span>
   alicePublicKey = alicePrivateKey.PublicKey  
  
   fmt.Println(<span class="hljs-string">"Alice Private Key (1024) :  "</span>, *alicePrivateKey)  
   fmt.Println(<span class="hljs-string">"Alice Public key (1024) "</span>, alicePublicKey)  
}
</code></pre>
<p><strong>The Output</strong> : This is sample output, it will varry when the program run again.</p>
<pre><code class="language-console">$ go rsakeygen.go
Alice Private Key (2048) :   {{252577609084739754533.....9407816575401] {10730....06322368 []}}
Alice Public key (2048)  {25257760908473975453370376......2333967994449957795953256930991 65537}
Alice Private Key (1024) :   {{12173262182204760381951.....449809420207757589211338372808685143776483631382443548335028637376375135294794510858217880714345611 []}}
Alice Public key (1024)  {121732621822047603819....3695643889226733382631 65537}

</code></pre>
<hr>
<%@ include file="footer_adsense.jsp"%>

<h2><a id="GenerateMultiPrimeKey_101"></a>GenerateMultiPrimeKey</h2>
<p>Having more than two prime factors is supported by the <a href="http://tools.ietf.org/html/rfc3447">PKCS#1 standard</a>. This is called a “multi-prime” key.  Go lang function <code>GenerateMultiPrimeKey</code> generates a multi-prime RSA keypair of the given bit size and the given random source. The Syntax for this function is</p>
<pre><code class="language-go"><span class="hljs-keyword">func</span> GenerateMultiPrimeKey(random io.Reader, nprimes <span class="hljs-typename">int</span>, bits <span class="hljs-typename">int</span>) (*PrivateKey, error)
</code></pre>
<p>For example the below code will have Three Prime Key Generation</p>
<pre><code class="language-go"><span class="hljs-keyword">package</span> main  
  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto/rand"</span>  
   <span class="hljs-string">"crypto/rsa"</span> 
   <span class="hljs-string">"fmt"</span>
   )  
  
<span class="hljs-keyword">func</span> main() {  
   size := <span class="hljs-number">768</span>  
  <span class="hljs-comment">// Three Prime Key Generation  </span>
  alicePrivateKey, err := rsa.GenerateMultiPrimeKey(rand.Reader, <span class="hljs-number">3</span>, size)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(err.Error)  
   }  
   <span class="hljs-comment">// Extract Public Key from RSA Private Key  </span>
   alicePublicKey := alicePrivateKey.PublicKey  
  
   fmt.Println(<span class="hljs-string">"Alice Private Key   "</span>, *alicePrivateKey)  
   fmt.Println(<span class="hljs-string">"Alice Public key  "</span>, alicePublicKey)  
}
</code></pre>
<p><strong>The Output:</strong> This is sample output, it will varry when the program run again.</p>
<pre><code class="language-console">$ go rsamultiprime.go
Alice Private Key    {{126134908529216858.......0175654062308......285310633005259496110624705393824297217491809883570809824786867373239057274829274133328288879778577235477274574684098643}]}}
Alice Public key   {1261349085292168580024695...... 8464445720671240782572554239501756540623080792125882018501372944881076823102151631 65537}
</code></pre>
<hr>
<h2><a id="RSA_OAEP_EncryptionDecryption_147"></a>RSA OAEP Encryption/Decryption</h2>
<p><strong>RSA</strong> is able to encrypt only a very limited amount of data, In order to encrypt reasonable amounts of data a hybrid scheme is commonly used: RSA is used to encrypt a key for a symmetric primitive like  AES-GCM.</p>
<ul>
<li>EncryptOAEP encrypts the given message with RSA-OAEP, encryption is performed using RSA public key.</li>
<li>DecryptOAEP decrypts the ciphertext message with  RSA-OAEP, decryption is performed using RSA private key.</li>
</ul>
<p>The Go Function for OAEP encryption and decryption.</p>
<pre><code> func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)
</code></pre>
<pre><code> func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)
</code></pre>
<p>The following code will show, how the RSA key pair is generated and then performed encryption and decryption using OAEP encryption scheme.</p>
<pre><code class="language-go"><span class="hljs-keyword">package</span> main  
  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto/rand"</span>  
   <span class="hljs-string">"crypto/rsa"</span>
   <span class="hljs-string">"crypto/sha256"</span> 
   <span class="hljs-string">"encoding/base64"</span> 
   <span class="hljs-string">"fmt"</span> 
   <span class="hljs-string">"os"</span>
   )  
<span class="hljs-keyword">func</span> main() {  
   <span class="hljs-comment">// Generate Alice RSA keys Of 2048 Buts  </span>
  alicePrivateKey, err := rsa.GenerateKey(rand.Reader, <span class="hljs-number">2048</span>)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(err.Error)  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-comment">// Extract Public Key from RSA Private Key  </span>
  alicePublicKey := alicePrivateKey.PublicKey  
  secretMessage := <span class="hljs-string">"Hello 8gwifi.org"</span>  
  encryptedMessage := EncryptOAEP(secretMessage,alicePublicKey);  
  fmt.Println(<span class="hljs-string">"Cipher Text  "</span>, encryptedMessage)  
  DecryptOAEP(encryptedMessage, *alicePrivateKey )  
} 
</code></pre>
<p><strong>The RSA OAEP Encryption</strong></p>
<ul>
<li>The Encryption logic is performed using RSA public key.</li>
<li>The random parameter ensure encrypting the same message twice doesn’t result in the same ciphertext</li>
<li>Encryption and decryption of a given message must use the same hash function</li>
<li>The label parameter may contain arbitrary data that will not be encrypted.</li>
</ul>
<pre><code class="language-go"><span class="hljs-keyword">func</span> EncryptOAEP(secretMessage <span class="hljs-typename">string</span>, pubkey rsa.PublicKey)  (<span class="hljs-typename">string</span>) {  
   label := []<span class="hljs-typename">byte</span>(<span class="hljs-string">"OAEP Encrypted"</span>)  
   <span class="hljs-comment">// crypto/rand.Reader is a good source of entropy for randomizing the  </span>
   <span class="hljs-comment">// encryption function.  </span>
   rng := rand.Reader   
   ciphertext, err := rsa.EncryptOAEP(sha256.New(), rng, &amp;pubkey, []<span class="hljs-typename">byte</span>(secretMessage),    label)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Fprintf(os.Stderr, <span class="hljs-string">"Error from encryption: %s\n"</span>, err)  
      <span class="hljs-keyword">return</span> <span class="hljs-string">"Error from encryption"</span>;  
   }  
   <span class="hljs-keyword">return</span> base64.StdEncoding.EncodeToString(ciphertext)  
}  
</code></pre>
<p><strong>The RSA OAEP Decryption</strong></p>
<pre><code class="language-go"><span class="hljs-keyword">func</span> DecryptOAEP(cipherText <span class="hljs-typename">string</span>, privKey rsa.PrivateKey)  (<span class="hljs-typename">string</span>) {  
   ct,_ := base64.StdEncoding.DecodeString(cipherText)  
   label := []<span class="hljs-typename">byte</span>(<span class="hljs-string">"OAEP Encrypted"</span>)  
  
   <span class="hljs-comment">// crypto/rand.Reader is a good source of entropy for blinding the RSA  </span>
 <span class="hljs-comment">// operation.  </span>
   rng := rand.Reader   
   plaintext, err := rsa.DecryptOAEP(sha256.New(), rng, &amp;privKey, ct, label)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Fprintf(os.Stderr, <span class="hljs-string">"Error from decryption: %s\n"</span>, err)  
      <span class="hljs-keyword">return</span> <span class="hljs-string">"Error from Decryption"</span>;  
   }  
   fmt.Printf(<span class="hljs-string">"Plaintext: %s\n"</span>, <span class="hljs-typename">string</span>(plaintext))  
 
   <span class="hljs-keyword">return</span> <span class="hljs-typename">string</span>(plaintext)  
}
</code></pre>
<p><strong>The Output</strong></p>
<pre><code class="language-console">$ go rsaencdec.go
Original Text   Hello 8gwifi.org
Cipher Text   6SXap813U4zGf6c9Ajyjl2sr1UE/ztv+lrZVQR2q/2cp6skSA+h0Y+4XL7r1y2YNi63d3c7CgYPKyqvZJiQq6OTEQ9VCbaCoHTglTYyV/0pbN7gmiYD6figXbgw1ScUg/SQyS2XbI278EwyFM2D2W15jppKR9zRHqEJyqhWdfCWiKlUFSdxGaXmjhWvZ4/EUqzYHmS3+VwQAmZmYfvKLEcjAGvfstp0sC9C7IcTi3zil5Guz4RovJvL540Hw75bDr9gQltddtir7L22yw9M9GM7YGxsyZNNez4c5EhA9vWJSJB+glrLfu60d9W2/NbCjF7mf6pOPfnkdVKhUzsjlcA==
Plaintext: Hello 8gwifi.org
</code></pre>


<hr>
<%@ include file="footer_adsense.jsp"%>

<h2><a id="RSA_PKCS1V1_5_SignVerify_255"></a>RSA_PKCS1-V1_5 Sign/Verify</h2>
<p><code>SignPKCS1v15</code> calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.</p>
<p>The Go function</p>
<pre><code class="language-go"><span class="hljs-keyword">func</span> SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []<span class="hljs-typename">byte</span>) ([]<span class="hljs-typename">byte</span>, error)
</code></pre>
<p><code>VerifyPKCS1v15</code> verifies an RSA PKCS#1 v1.5 signature. hashed is the result of hashing the input message.</p>
<p>The Go function</p>
<pre><code class="language-go"><span class="hljs-keyword">func</span> VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []<span class="hljs-typename">byte</span>, sig []<span class="hljs-typename">byte</span>) error
</code></pre>
<ul>
<li>Signature generation is performed using RSA private Key</li>
<li>Signature Verification is performed with RSA public Key.</li>
</ul>
<p>The following example code will generate RSA keys of size 2048 and then perform RSA Sign/verify using the  PKCS1-V1_5 signature scheme.</p>
<pre><code class="language-go"><span class="hljs-keyword">package</span> main  
  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto"</span>  
   <span class="hljs-string">"crypto/rand"</span>
   <span class="hljs-string">"crypto/rsa"</span>
   <span class="hljs-string">"crypto/sha256"</span> 
   <span class="hljs-string">"encoding/base64"</span> 
   <span class="hljs-string">"fmt"</span> 
   <span class="hljs-string">"os"</span>
   )  
  
<span class="hljs-keyword">func</span> main() {  
  
   <span class="hljs-comment">// Generate Alice RSA keys Of 2048 Buts  </span>
  alicePrivateKey, err := rsa.GenerateKey(rand.Reader, <span class="hljs-number">2048</span>)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(err.Error)  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-comment">// Extract Public Key from RSA Private Key  </span>
   alicePublicKey := alicePrivateKey.PublicKey  
   secretMessage := <span class="hljs-string">"Hello 8gwifi.org"</span>  
   fmt.Println(<span class="hljs-string">"Original Text  "</span>, secretMessage)  
   signature := SignPKCS1v15(secretMessage,*alicePrivateKey);  
   fmt.Println(<span class="hljs-string">"Singature :  "</span>, signature)  
   verif := VerifyPKCS1v15(signature, secretMessage,  alicePublicKey )  
   fmt.Println(verif)  
}
</code></pre>
<ul>
<li>Only small messages can be signed directly, thus the hash of a message, rather than the message itself, is signed.</li>
</ul>
<pre><code class="language-go"><span class="hljs-keyword">func</span> SignPKCS1v15(plaintext <span class="hljs-typename">string</span>, privKey rsa.PrivateKey)  (<span class="hljs-typename">string</span>) {  
   <span class="hljs-comment">// crypto/rand.Reader is a good source of entropy for blinding the RSA  </span>
 <span class="hljs-comment">// operation.  </span>
   rng := rand.Reader   
   hashed := sha256.Sum256([]<span class="hljs-typename">byte</span>(plaintext))  
   signature, err := rsa.SignPKCS1v15(rng, &amp;privKey, crypto.SHA256, hashed[:])  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Fprintf(os.Stderr, <span class="hljs-string">"Error from signing: %s\n"</span>, err)  
      <span class="hljs-keyword">return</span> <span class="hljs-string">"Error from signing"</span>  
  }  
   <span class="hljs-keyword">return</span> base64.StdEncoding.EncodeToString(signature)  
}
</code></pre>
<ul>
<li>Signature Verification is performed using RSA Public key, and verification is done along with the original message.</li>
</ul>
<pre><code class="language-go"><span class="hljs-keyword">func</span> VerifyPKCS1v15(signature <span class="hljs-typename">string</span>, plaintext <span class="hljs-typename">string</span>, pubkey rsa.PublicKey) (<span class="hljs-typename">string</span>) {  
   sig, _ := base64.StdEncoding.DecodeString(signature)  
   hashed := sha256.Sum256([]<span class="hljs-typename">byte</span>(plaintext))  
   err := rsa.VerifyPKCS1v15(&amp;pubkey, crypto.SHA256, hashed[:], sig)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Fprintf(os.Stderr, <span class="hljs-string">"Error from verification: %s\n"</span>, err)  
      <span class="hljs-keyword">return</span> <span class="hljs-string">"Error from verification:"</span>  
  }  
   <span class="hljs-keyword">return</span> <span class="hljs-string">"Signature Verification Passed"</span>  
}
</code></pre>
<p><strong>The output</strong></p>
<pre><code class="language-console">$ go rsasignverify.go
Original Text   Hello 8gwifi.org
Signature :   FwEix1XfSsPB+fTeWCSqSHlkT+5gSmXDKG/rgjIlvvH15qTUJAbJfkpReIvw/xM+8v6RclwJg8TE8c2v20WKbvTC37B46XrrxwMz9w0gGOde4kjFTKqb6TiERqkrgAO/6fFGYWQtmqJf3j/18ztmYGcYRgVZcNExTyVA7eskVw3jLAxiMDdgFjCvBLJrtpiGxl/jUGf27dbWU6engRPKobcwAN0YBlrJbetVHS0VsINqPXXg7GfrSrLZ0YI7R6yR2yaRsn0nexPs8ybyHqpIKd0q1PNBbQ4fs+BWrcz1UZnbXOh9jrvF/yLcR9cPeUBD1YV3GNtpjyqILuiM3LjiQQ==
Signature Verification Passed
</code></pre>
<hr>
<h2><a id="RSA_PSS_SignVerify_360"></a>RSA_PSS Sign/Verify</h2>
<p>Go Lang function <code>SignPSS</code> calculates the signature of hashed using RSASSA-PSS, The signature generation is performed using RSA private key.</p>
<pre><code class="language-go"><span class="hljs-keyword">func</span> SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []<span class="hljs-typename">byte</span>, opts *PSSOptions) ([]<span class="hljs-typename">byte</span>, error)
</code></pre>
<p>Go Lang function <code>VerifyPSS</code> Verify the signature of hashed using RSASSA-PSS, The signature verification is performed using RSA public key along with plain text message.</p>
<pre><code class="language-go"><span class="hljs-keyword">func</span> VerifyPSS(pub *PublicKey, hash crypto.Hash, hashed []<span class="hljs-typename">byte</span>, sig []<span class="hljs-typename">byte</span>, opts *PSSOptions) error
</code></pre>
<p>Here is the example of performing PSS Signature generation and verification.</p>
<ul>
<li>An RSA key is generated.</li>
<li>Performed the Signature generation of the given plain text message using the <code>SignPSS</code> method.</li>
<li>After that the signature is passed <code>VerifyPSS</code> method to verify the signature.</li>
</ul>
<pre><code class="language-go"><span class="hljs-keyword">package</span> main  
  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto"</span>  
   <span class="hljs-string">"crypto/rand"</span> 
   <span class="hljs-string">"crypto/rsa"</span> 
   <span class="hljs-string">"crypto/sha256"</span> 
   <span class="hljs-string">"encoding/base64"</span> 
   <span class="hljs-string">"fmt"</span> 
   <span class="hljs-string">"os"</span>)  
  
<span class="hljs-keyword">func</span> main() {  
  
   <span class="hljs-comment">// Generate Alice RSA keys Of 2048 Buts  </span>
   alicePrivateKey, err := rsa.GenerateKey(rand.Reader, <span class="hljs-number">2048</span>)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(err.Error)  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-comment">// Extract Public Key from RSA Private Key  </span>
   alicePublicKey := alicePrivateKey.PublicKey  
   secretMessage := <span class="hljs-string">"Hello 8gwifi.org"</span>  
   fmt.Println(<span class="hljs-string">"Original Text  "</span>, secretMessage)  
   signature := SignPSS(secretMessage,*alicePrivateKey);  
   fmt.Println(<span class="hljs-string">"Signature :  "</span>, signature)  
   verif := VerifyPSS(signature, secretMessage,  alicePublicKey )  
   fmt.Println(verif)  
}
</code></pre>
<p>Logic to perform signing of the message.</p>
<pre><code class="language-go"><span class="hljs-keyword">func</span> SignPSS(plaintext <span class="hljs-typename">string</span>, privKey rsa.PrivateKey)  (<span class="hljs-typename">string</span>) {  
   <span class="hljs-comment">// crypto/rand.Reader is a good source of entropy for blinding the RSA operation.  </span>
   rng := rand.Reader  
   hashed := sha256.Sum256([]<span class="hljs-typename">byte</span>(plaintext))  
   <span class="hljs-keyword">var</span> opts rsa.PSSOptions  
   signature, err := rsa.SignPSS(rng, &amp;privKey, crypto.SHA256, hashed[:],&amp;opts)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Fprintf(os.Stderr, <span class="hljs-string">"Error from signing: %s\n"</span>, err)  
      <span class="hljs-keyword">return</span> <span class="hljs-string">"Error from signing"</span>  
  }  
   <span class="hljs-keyword">return</span> base64.StdEncoding.EncodeToString(signature)  
}
</code></pre>
<p>Logic to perform verification of the signature using the RSA public key,</p>
<pre><code class="language-go"><span class="hljs-keyword">func</span> VerifyPSS(signature <span class="hljs-typename">string</span>, plaintext <span class="hljs-typename">string</span>, pubkey rsa.PublicKey) (<span class="hljs-typename">string</span>) {  
   sig, _ := base64.StdEncoding.DecodeString(signature)  
   hashed := sha256.Sum256([]<span class="hljs-typename">byte</span>(plaintext))  
   <span class="hljs-keyword">var</span> opts rsa.PSSOptions  
   err := rsa.VerifyPSS(&amp;pubkey, crypto.SHA256, hashed[:], sig,&amp;opts)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Fprintf(os.Stderr, <span class="hljs-string">"Error from verification: %s\n"</span>, err)  
      <span class="hljs-keyword">return</span> <span class="hljs-string">"Error from verification:"</span>  
  }  
   <span class="hljs-keyword">return</span> <span class="hljs-string">"Signature Verification Passed"</span>  
}
</code></pre>
<p><strong>The output</strong></p>
<pre><code class="language-console">$ go rsapsssignverify.go
Original Text   Hello 8gwifi.org
Signature :   fMKqR0UIinPM4YgqjWqtQioi9SWLMASMRgoyAYUUlCy3yUHpNnXDjhVjRHAAUMDM1LoVpuCeYsdDttS3EJdAeyuF7CxRg9mv24myUa+wNTA8lVOP+OOg8hUKHSa7pMHvpuZSuW35fYcQrbaUltcrlsqN9ndcNUY2GEosuHwZwm/jlt+pUl/ONrETCdwXeq2z3CLnrBbuuRdw9F2+YrlB1jyWDjkR2kIeYjw8MS7UtZkqZ4f3DZNbtCAYdw+DJR/I2Ej0mhRRiFYPuUL2w0KUWxSaPYjZaYQJWmJfVDcVAluwEns0H7RFrqGdh2Zxa70uEcS1AT3Omo77ItAn0L7omw==
Signature Verification Passed
</code></pre>

<hr>
<%@ include file="footer_adsense.jsp"%>

<h2><a id="Export_RSA_Key_to_PEM_Format_462"></a>Export RSA Key to PEM Format</h2>
<ul>
<li>First Generate an RSA Key pair.</li>
</ul>
<pre><code class="language-go"><span class="hljs-keyword">package</span> main  
  
<span class="hljs-keyword">import</span> (  
   <span class="hljs-string">"crypto/rand"</span>  
   <span class="hljs-string">"crypto/rsa"</span> 
   <span class="hljs-string">"crypto/x509"</span> 
   <span class="hljs-string">"encoding/asn1"</span> 
   <span class="hljs-string">"encoding/pem"</span>
   <span class="hljs-string">"fmt"</span>
   <span class="hljs-string">"os"</span> 
   <span class="hljs-string">"bufio"</span>
   )  
  
<span class="hljs-keyword">func</span> main() {  
   <span class="hljs-comment">// Generate Alice RSA keys Of 2048 Buts  </span>
    alicePrivateKey, err := rsa.GenerateKey(rand.Reader, <span class="hljs-number">2048</span>)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(err.Error)  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-comment">// Extract Public Key from RSA Private Key  </span>
   alicePublicKey := alicePrivateKey.PublicKey  
   fmt.Println(<span class="hljs-string">"Alice Private Key :  "</span>, *alicePrivateKey)  
   fmt.Println(<span class="hljs-string">"Alice Public key "</span>, alicePublicKey)
</code></pre>
<ul>
<li>
<p>Once the RSA Key pair is generated store it in PEM format with pkcs encoding.</p>
<pre><code class="language-go"><span class="hljs-comment">// Method to store the RSA keys in pkcs8 Format  </span>
savePKCS8RSAPEMKey(<span class="hljs-string">"/tmp/alicepriv.pem"</span>, alicePrivateKey)  
<span class="hljs-comment">// Method to store the RSA keys in pkcs1 Format  </span>
savePKCS1RSAPublicPEMKey(<span class="hljs-string">"/tmp/alicepub.pem"</span>,&amp;alicePublicKey)  
<span class="hljs-comment">// Method to Strore in Public Key format </span>
savePublicPEMKey(<span class="hljs-string">"/tmp/alicepub1.pem"</span>,alicePublicKey)
</code></pre>
</li>
<li>
<p>Method to store the RSA keys in pkcs8 Format <code>-----BEGIN RSA PRIVATE KEY-----</code> and   <code>-----END RSA PRIVATE KEY-----</code></p>

<pre><code class="language-go"><span class="hljs-keyword">func</span> savePKCS8RSAPEMKey(fName <span class="hljs-typename">string</span>, key *rsa.PrivateKey) {  
   outFile, err := os.Create(fName)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-keyword">defer</span> outFile.Close()  
   <span class="hljs-comment">//converts a private key to ASN.1 DER encoded form.  </span>
  <span class="hljs-keyword">var</span> privateKey = &amp;pem.Block{  
      Type:  <span class="hljs-string">"RSA PRIVATE KEY"</span>,  
      Bytes: x509.MarshalPKCS1PrivateKey(key),  
   }  
   err = pem.Encode(outFile, privateKey)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
}
</code></pre>
</li>
<li>
<p>Method to store the RSA keys in pkcs1 Format <code>-----BEGIN RSA PUBLIC KEY-----</code> and   <code>-----END RSA PUBLIC KEY-----</code></p>
</li>
</ul>
<pre><code class="language-go"><span class="hljs-keyword">func</span> savePKCS1RSAPublicPEMKey(fName <span class="hljs-typename">string</span>, pubkey *rsa.PublicKey) {  
   <span class="hljs-comment">//converts an RSA public key to PKCS#1, ASN.1 DER form.  </span>
  <span class="hljs-keyword">var</span> pemkey = &amp;pem.Block{  
      Type:  <span class="hljs-string">"RSA PUBLIC KEY"</span>,  
      Bytes: x509.MarshalPKCS1PublicKey(pubkey),  
   }  
   pemfile, err := os.Create(fName)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-keyword">defer</span> pemfile.Close()  
   err = pem.Encode(pemfile, pemkey)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
}
</code></pre>
<ul>
<li>Method to store the RSA keys in public key Format <code>-----BEGIN PUBLIC KEY-----</code> and   <code>-----END PUBLIC KEY-----</code></li>
</ul>
<pre><code class="language-go"><span class="hljs-keyword">func</span> savePublicPEMKey(fileName <span class="hljs-typename">string</span>, pubkey rsa.PublicKey) {  
   asn1Bytes, err := asn1.Marshal(pubkey)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-keyword">var</span> pemkey = &amp;pem.Block{  
      Type:  <span class="hljs-string">"PUBLIC KEY"</span>,  
      Bytes: asn1Bytes,  
   }  
   
   pemfile, err := os.Create(fileName)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-keyword">defer</span> pemfile.Close()  
   err = pem.Encode(pemfile, pemkey)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
}
</code></pre>
<hr>
<h2><a id="Import_PEM_Key_to__RSA_Format_585"></a>Import PEM Key to  RSA Format</h2>
<ul>
<li>
<p>To import PEM key first read the file, parse it and then use <code>pem.Decode</code> to construct the required interface.</p>
<pre><code class="language-go">importedAliceRSAPrivateKey := *loadRSAPrivatePemKey(<span class="hljs-string">"/tmp/alicepriv.pem"</span>);  
importedAliceRSAPublicKey := loadPublicPemKey(<span class="hljs-string">"/tmp/alicepub.pem"</span>);  
fmt.Println(<span class="hljs-string">"Imported Alice Private Key"</span>, importedAliceRSAPrivateKey)  
fmt.Println(<span class="hljs-string">"Imported Alice Public Key"</span>, *importedAliceRSAPublicKey)
}
</code></pre>
</li>
<li>
<p>Load RSA private key which is stored in PEM format and create RSA private Key using go <code>x509.ParsePKCS1PrivateKey</code></p>
</li>
</ul>
<pre><code class="language-go"><span class="hljs-keyword">func</span> loadRSAPrivatePemKey(fileName <span class="hljs-typename">string</span>)  (*rsa.PrivateKey)  {  
   privateKeyFile, err := os.Open(fileName)  
  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
  
   pemfileinfo, _ := privateKeyFile.Stat()  
   <span class="hljs-keyword">var</span> size <span class="hljs-typename">int64</span> = pemfileinfo.Size()  
   pembytes := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, size)  
   buffer := bufio.NewReader(privateKeyFile)  
   _, err = buffer.Read(pembytes)  
  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   data, _ := pem.Decode([]<span class="hljs-typename">byte</span>(pembytes))  
   privateKeyFile.Close()  
   privateKeyImported, err := x509.ParsePKCS1PrivateKey(data.Bytes)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-keyword">return</span> privateKeyImported  
}
</code></pre>
<ul>
<li>Load  public key stored in PEM format and create RSA public Key using go <code>x509.ParsePKCS1PublicKey</code></li>
</ul>
<pre><code class="language-go"><span class="hljs-keyword">func</span> loadPublicPemKey (fileName <span class="hljs-typename">string</span>)  (*rsa.PublicKey) {  
  
   publicKeyFile,err := os.Open(fileName)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
  
   pemfileinfo, _ := publicKeyFile.Stat()  
  
   size  := pemfileinfo.Size()  
   pembytes := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">byte</span>, size)  
   buffer := bufio.NewReader(publicKeyFile)  
   _, err = buffer.Read(pembytes)  
   data, _ := pem.Decode([]<span class="hljs-typename">byte</span>(pembytes))  
   publicKeyFile.Close()  
   publicKeyFileImported, err := x509.ParsePKCS1PublicKey(data.Bytes)  
   <span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {  
      fmt.Println(<span class="hljs-string">"Fatal error "</span>, err.Error())  
      os.Exit(<span class="hljs-number">1</span>)  
   }  
   <span class="hljs-keyword">return</span> publicKeyFileImported  
}
</code></pre>
<p><strong>The output</strong>  : Alice private and public key before import and after import are same.</p>
<pre><code class="language-console">$ go rsapem.go
Alice Private Key :   {27955432259048807217......5903087222243000281118047 65537}
Alice Public key  {2795543225904880721713151983.....3087222243000281118047 65537}
Imported Alice Private Key {{27955432259048807217......5903087222243000281118047 65537} 
Imported Alice Public Key {2795543225904880721713151983.....3087222243000281118047 65537}
</code></pre>

<%@ include file="thanks.jsp"%>

<hr>

<%@ include file="addcomments.jsp"%>
      <!-- Comments Form -->
    

          <!-- Single Comment -->
 

          <!-- Comment with nested comments -->
        
          

        </div>

		
        
        <!-- Sidebar Widgets Column -->
        <div class="col-md-4">

          <!-- Ad Widget -->
         <%@ include file="footer_adsense.jsp"%> 
         
         
         <%@ include file="related-go.jsp"%>
         
         <%@ include file="related-cryptography.jsp"%>
         
         <%@ include file="related-window-crypto.jsp"%>

		 
          <!-- Article Widget -->
         <%@ include file="related-ansible.jsp"%>
         
         <%@ include file="related-kube.jsp"%>
         
         
         <%@ include file="related-openstack.jsp"%>
         <%@ include file="related-linux.jsp"%>
         
         
         <!-- Topic Widget -->
         <%@ include file="side.jsp"%>
         
           <!-- Add Comments Support -->
         
         
         

        </div>


      </div>
      
      <!-- /.row -->


	
    
    </div>
    
    
    
    
    <!-- /.container -->

    <!-- Footer -->
    <footer class="py-5 bg-dark">
      <div class="container">
        <p class="m-0 text-center text-white">Copyright &copy; 8gwifi.org 2018</p>
      </div>
      <!-- /.container -->
    </footer>
    
    Here

    <!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>


  </body>

</html>